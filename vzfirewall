#!/usr/bin/perl -w
#
# vzfirewall:  A simple firewall for OpenVZ
#
# See 'vzfirewall -h' for documentaion.
#
# Check https://github.com/DmitryKoterov/vzfirewall
# for latest version and development info.

use strict;
use Pod::Usage;
use File::Basename;
use POSIX 'strftime';
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);
use Switch;

my $VERSION = "1.13, 2014-01-20";

my %conf = ();  # running configuration (defaults + config file + cli opts)
my %opt = ();   # command line options

my @ICMP_TYPES;
my @FAILSAFE_ADDRS;
GetOptions(\%opt, 'help|h', 'version|V', 'apply|a', 'test|t',
	'vzfw-conf|conf|c=s', 'force|f', 'verbose|v',
	'iptables-rules|rules=s', 'openvz-conf-dir|dir|d=s',
	'icmp-types=s{1,}' => \@ICMP_TYPES,
	'failsafe-addrs=s{1,}' => \@FAILSAFE_ADDRS,
) or exit(1);

if ($opt{'vzfw-conf'}) {
    $conf{'vzfw-conf'} = $opt{'vzfw-conf'};
    read_vzfirewall_conf( $conf{'vzfw-conf'}, \%conf, \%opt );
}

if ($opt{'openvz-conf-dir'}) {
    $conf{'openvz-conf-dir'} = $opt{dir};
} elsif (! $conf{'openvz-conf-dir'}) {
    ($conf{'openvz-conf-dir'}) = grep { -d $_ } ("/etc/sysconfig/vz-scripts", "/etc/vz/conf");
}

unless ($conf{'openvz-conf-dir'} && -d $conf{'openvz-conf-dir'}) {
	print STDERR qq(
ERROR: vzfirewall could not find openvz container conf files.
(Is openvz installed?)

Use -d to specify their location.

);

	pod2usage( -verbose => 1 );
}

unless ($conf{'vzfw-conf'}) {
    ($conf{'vzfw-conf'}) = dirname($conf{'openvz-conf-dir'}) . "/vzfirewall.conf";
    if ( -f $conf{'vzfw-conf'} ) {
        read_vzfirewall_conf( $conf{'vzfw-conf'}, \%conf, \%opt );
    }
}

unless ($conf{'openvz-conf-dir'} && -d $conf{'openvz-conf-dir'}) {
    die "ERROR: invalid openvz container conf directory.\n"
        . "Fix OPENVZ_CONF_DIR in $conf{'vzfw-conf'}.\n";
}

my ($RULES_FALLBACK) = dirname($conf{'openvz-conf-dir'}) . "/vzfirewall.rules";
my $RULES_FALLBACK_USED = 0;

my $IPTABLES;
if ($opt{'iptables-rules'}) {
    $IPTABLES = $opt{'iptables-rules'};
} elsif ($conf{'iptables-rules'}) {
    $IPTABLES = $conf{'iptables-rules'};
} else {
    ($IPTABLES) = grep { -f $_ } (
        "/etc/sysconfig/iptables",  # RHEL systems
        "/etc/iptables/rules.v4",   # iptables-persist
        $RULES_FALLBACK             # vzfirewall fallback
    );
    unless ($IPTABLES) {
        $IPTABLES = $RULES_FALLBACK;
        $RULES_FALLBACK_USED = 1;
    }
}

if ($opt{help}) {
    pod2usage( -verbose => $opt{verbose} ? 2 : 1 );
}
if ($opt{version}) {
    print "vzfirewall $VERSION\n"; exit(0)
}

@ICMP_TYPES = split(" ", join(' ', @ICMP_TYPES));           # set via Getoptions
if ($ICMP_TYPES[0]) {
    $conf{'icmp-types'} = \@ICMP_TYPES;
} elsif (! $conf{'icmp-types'}) {
    @ICMP_TYPES = (3, 4, 11, 12, 8,);
    $conf{'icmp-types'} = \@ICMP_TYPES;
}

@FAILSAFE_ADDRS = split(" ", join(' ', @FAILSAFE_ADDRS));   # set via Getoptions
if ($FAILSAFE_ADDRS[0]) {
    $conf{'failsafe-addrs'} = \@FAILSAFE_ADDRS;
} elsif (! $conf{'failsafe-addrs'}) {
    @FAILSAFE_ADDRS = ("any",);
    $conf{'failsafe-addrs'} = \@FAILSAFE_ADDRS;
}

if ($RULES_FALLBACK_USED && $opt{verbose}) {
    print STDERR qq(
NOTICE:  vzfirewall did not find any persistent iptables rules locations.
vzfirewall will write iptables rules to:  $RULES_FALLBACK

You will need to arrange for those rules to be loaded at system boot time,
eg. by adding this command to system startup scripts:

        iptables-restore < $RULES_FALLBACK

Or you may find a package such as iptables-persistent for your OS to handle
this for you.

);
}

if ($opt{test}) {
    do_apply(1);
} elsif ($opt{apply}) {
    do_apply(0, defined $opt{force});
} else {
    pod2usage( -verbose => 1 );
}

sub do_apply {
	my ($test_mode, $force) = @_;
	
	my @cmds = ();
	push @cmds, "##\n## PLEASE DO NOT EDIT THIS FILE MANUALLY!!!\n##\n";
	push @cmds, "## It is generated by " . basename($0) . "\n";
	push @cmds, "## All changes will be lost on re-generation!\n##\n";
	push @cmds, "*filter\n";
	push @cmds, ":INPUT ACCEPT [0:0]\n"; # MUST be ACCEPT by default for safety (see footer)
	push @cmds, ":FORWARD ACCEPT [0:0]\n";
	push @cmds, ":OUTPUT ACCEPT [0:0]\n";
	push @cmds, "\n\n";
	push @cmds, "##\n## Basic logging rules with policy actions\n##\n";
	push @cmds, ":vzfw-log-allow - [0:0]\n";
	push @cmds, ":vzfw-log-deny - [0:0]\n";
	push @cmds, "# logging with RETURN policy\n";
	push @cmds, "-A vzfw-log-allow -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix \"[VZFW ALLOW] \"\n";
	push @cmds, "# logging with DENY policy\n";
	push @cmds, "-A vzfw-log-deny -m state --state INVALID -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix \"[VZFW BLOCK] \"\n";
	push @cmds, "-A vzfw-log-deny -m state --state INVALID -j DROP\n";
	push @cmds, "-A vzfw-log-deny -m addrtype --dst-type MULTICAST -j DROP\n";
	push @cmds, "-A vzfw-log-deny -m addrtype --dst-type BROADCAST -j DROP\n";
	push @cmds, "-A vzfw-log-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix \"[VZFW BLOCK] \"\n";
	push @cmds, "-A vzfw-log-deny -j REJECT --reject-with icmp-admin-prohibited\n";
	push @cmds, "\n\n";
	push @cmds, "##\n## Default opened on loopback interface.\n##\n";
	push @cmds, "-A INPUT -i lo -j ACCEPT\n";
	push @cmds, "-A OUTPUT -o lo -j ACCEPT\n";
	push @cmds, "-A FORWARD -i lo -j ACCEPT\n";
	push @cmds, "\n##\n## Stop spoofing of our addresses.\n##\n";
	push @cmds, "-A INPUT -m addrtype --src-type LOCAL -j vzfw-log-deny\n";
	for my $chain ("INPUT", "OUTPUT", "FORWARD") {
		push @cmds, "\n##\n## Firewall states ($chain).\n##\n";
		push @cmds, "-A $chain -m state --state INVALID -j vzfw-log-deny\n";
		push @cmds, "-A $chain -m state --state ESTABLISHED,RELATED -j ACCEPT\n";

		push @cmds, "# Allowed icmp types\n";
		for my $type ( @{$conf{'icmp-types'}} ) {
			push @cmds, "-A $chain -p icmp --icmp-type $type -j ACCEPT\n";
		}
	}
	if ( grep { /any/i } @{$conf{'failsafe-addrs'}} ) {
		push @cmds, "\n# Failsafe SSH access open to hardware node.\n";
		push @cmds, "-A INPUT -p tcp --dport 22 -j vzfw-log-allow\n";
		push @cmds, "-A INPUT -p tcp --dport 22 -j ACCEPT\n";
	} elsif ( grep { /none/i } @{$conf{'failsafe-addrs'}} ) {
		push @cmds, "\n# Failsafe SSH access to hardware node is disabled.\n";
	} else {
		push @cmds, "\n# Failsafe SSH access to hardware node.\n";
		for my $addr ( @{$conf{'failsafe-addrs'}} ) {
			push @cmds, "-A INPUT -p tcp -s $addr --dport 22 -j vzfw-log-allow\n";
			push @cmds, "-A INPUT -p tcp -s $addr --dport 22 -j ACCEPT\n";
		}
	}
	push @cmds, "\n\n";
	
	# Collect all data.
	my @parsed = ();
	foreach my $ct_conf (glob($conf{'openvz-conf-dir'} . "/*.conf")) {
		my $basename = basename($ct_conf);
		my $opts = read_openvz_conf($ct_conf);
		my ($rules, $custom) = read_rules($opts->{FIREWALL});
		my @dst_ips;
		if ($basename ne "0.conf") {
			my $ips = $opts->{IP_ADDRESS} or die "Cannot find IP_ADDRESS in $ct_conf\n";
			$ips =~ s/^\s+|\s+$//sg;
			@dst_ips = split /\s+/, $ips;
		} else {
			# "" meands "host node IPs" (everything)
			@dst_ips = ("");
		}
		push @parsed, [ $basename, \@dst_ips, $rules, $custom ];
	}
	
	# Generate OPEN commands.
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		next if !@$rules && !@$custom;
		push @cmds, "##\n## Rules from $basename\n##\n";
		foreach my $dst_ip (@$dst_ips) {
			foreach my $pair (@$rules) {
				push @cmds, generate_open_rule(
					$pair->[1], # src ip
					$dst_ip,    # dst ip
					$pair->[0], # dst port(s)
					$pair->[2], # comment
				);
			}
			my @ccmds = ();
			foreach my $rule_c (@$custom) {
				my $rule = $rule_c;
				$rule =~ s/\$THIS/$dst_ip/sg or next;
				die "You cannot use \$THIS in $basename: it is for VEs only\n" if !$dst_ip;
				push @ccmds, $rule . "\n";
			}
			if (@ccmds) {
				push @cmds, "# CUSTOM for $dst_ip ($basename):\n";
				push @cmds, @ccmds;
				push @cmds, "\n";
			}
		}
		my @ccmds = ();
		foreach my $rule (@$custom) {
			next if $rule =~ /\$THIS/s;
			push @ccmds, $rule . "\n";
		}
		if (@ccmds) {
			push @cmds, "# CUSTOM for VE $basename:\n";
			push @cmds, @ccmds;
		}
		push @cmds, "\n\n";
	}
	
	# Generate CLOSE rules for all destination IPs.
	push @cmds, "##\n## All other access to these IPs is closed.\n##\n";
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		push @cmds, map { generate_close_rule($_) } @$dst_ips;
	}

	# Generate OPEN rules for outgoing connections.
	push @cmds, "\n\n##\n## Outgoing connections are permitted.\n##\n";
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		push @cmds, map { generate_outgoing_rule($_) } @$dst_ips;
	}

	push @cmds, "\n\n##\n## Default action for incoming packets - reject.\n##\n";
	push @cmds, "-A INPUT -j vzfw-log-deny\n";
	push @cmds, "-A FORWARD -j vzfw-log-deny\n";
	push @cmds, "COMMIT\n";
	my $cmds = join "", @cmds;
	
	my $prev = "";
	open(local *F, ">>", $IPTABLES) and close(F);
	if (open(local *F, $IPTABLES)) {
		local $/;
		$prev = <F>;
		close(F);
	}

	if ($prev ne $cmds) {
		print STDERR "--DIFF--\n";
		open(local *P, "| diff $IPTABLES - >&2");
		print P $cmds;
		close(P);
		print STDERR "--RULES--\n" if $test_mode;
	}
	
	if ($test_mode) {
		print $cmds;
	} else {
		if ($force || $prev ne $cmds) {
			print STDERR "Testing new rules...\n";
			open(local *P, "| iptables-restore -t");
			print P $cmds;
			if (!close(P)) {
				die "Test failed. Apply nothing.\n";
			}
			# Use cp instead of mv, because this file could be a symlink!
			system("/bin/cp", $IPTABLES, $IPTABLES . ".bak." . strftime("%Y-%m-%d_%H-%M-%S", localtime(time)));
			open(local *F, ">", $IPTABLES) or die "Cannot create $IPTABLES: $!\n";
			print F $cmds;
			close(F);
			print STDERR "Applying new rules...\n";
			system("iptables-restore < $IPTABLES");
		} else {
			die "Nothing is changed.\n";
		}
	}
}

sub read_rules {
	my ($text) = @_;
	return ([], []) if !$text;
	#return ([[ "*", "*", "ANYTHING" ]], []) if !$text;
	my @rules = ();
	my @custom = ();
	my $port = "*";
	foreach (split /\n/, $text) {
		s/^\s+|[#;].*|\s+$//sg;
		next if !$_;
		if (/^\s*\[(.*)\]\s*$/s) {
			$port = $1;
			$port =~ s/\s+//sg;
			next;
		}
		if (lc $port eq "custom") {
			push @custom, $_;
			next;
		}
		my $ips = resolve($_);
		foreach my $ip (@$ips) {
			push @rules, [ $port, $ip, $_ ];
		}
	}
	return (\@rules, \@custom);
}

sub generate_open_rule {
	my ($src_ip, $dst_ip, $dst_port, $comment) = @_;
	my @lines = ("# $comment -> $dst_ip:$dst_port\n");
	my $proto = "tcp";
	if ($dst_port =~ /^([a-z]+):(.*)$/is) {
		$proto = $1;
		$dst_port = $2;
	}
	my $rule =
		($src_ip && $src_ip ne "*"? " -s $src_ip" : "") . 
		($dst_ip && $dst_ip ne "*"? " -d $dst_ip" : "") . 
		($dst_port ne "*"? " -m multiport -p $proto --dports $dst_port" : "") .
		" -j ACCEPT";
	$rule =~ s/\s+/ /sg;
	my $chain = $dst_ip? "FORWARD" : "INPUT";
	push @lines, "-A $chain" . $rule . "\n";
	return join "", @lines;
}

sub generate_close_rule {
	my ($dst_ip) = @_;
	return ($dst_ip && $dst_ip ne "*"? "-A FORWARD -d $dst_ip" : "-A INPUT") . " -j vzfw-log-deny\n";
}

sub generate_outgoing_rule {
	my ($src_ip) = @_;
	return ($src_ip && $src_ip ne "*"? "-A FORWARD -s $src_ip" : "-A OUTPUT") . " -j ACCEPT\n";
}

sub read_openvz_conf {
	my ($conf) = @_;
	open(local *F, $conf) or die "Cannot open $conf: $!\n";
	local $/;
	$_ = <F>;
	close(F);
	my %opts = ();
	my @matches = m/^([#](?=FIREWALL))? (\w+) \s* = \s* " ([^\"]*) "/mxg;
	for (my $i = 0; $i < @matches; $i += 3) {
		my $data = $matches[$i + 2];
		$data =~ s/^#//mg if $matches[$i];
		$data =~ s/'/"/sg;
		$opts{$matches[$i + 1]} = $data;
	}
	return \%opts;
}

sub read_vzfirewall_conf {
    my ($conf, $cfg, $cli) = @_;
    my ($l, $n, $v);
    my %filecfg = ();

    open(local *F, $conf) or die "Cannot open $conf: $!\n";
    while (<F>) {
        chop ($l = $_);

        $l =~ s/#.*$//;     # comments
        $l =~ s/^\s*//;     # leading spaces
        $l =~ s/\s*$//;     # trailing spaces

        if ($l ne "") {
            ($n, $v) = split (/\w*=\w*/, $l);

            $n = join(" ", split(" ", $n) );
            $n =~ s/^\s*//;
            $n =~ s/\s*$//;

            $v = join(" ", split(" ", $v) );
            $v =~ s/^\s*//;
            $v =~ s/\s*$//;

            switch ($n) {
                case "OPENVZ_CONF_DIR" {
                    unless ($$cli{'openvz-conf-dir'}) {
                        $$cfg{'openvz-conf-dir'} = $v;
                    }
                }
                case "IPTABLES_RULES" {
                    unless ($$cli{'iptables-rules'}) {
                        $$cfg{'iptables-rules'} = $v;
                    }
                }
                case "ICMP_TYPES" {
                    unless ($$cli{'icmp-types'}) {
                        my (@v) = split(" ", $v);
                        $$cfg{'icmp-types'} = \@v;
                    }
                }
                case "FAILSAFE_ADDRS" {
                    unless ($$cli{'failsafe-addrs'}) {
                        my (@v) = split(" ", $v);
                        $$cfg{'failsafe-addrs'} = \@v;
                    }
                }
            }
        }
    }
    close(F);
    return;
}

my %resolved = ();
sub resolve {
	my ($host) = @_;
	return [ $host ] if $host =~ /^\d+\.\d+\.\d+\.\d+|^\*$/s;
	return $resolved{$host} if $resolved{$host};
	my @ips = (`host $host.`||"") =~ /(\d+\.\d+\.\d+\.\d+$)/mg or die "Cannot resolve $host\n";
	foreach (@ips) {
		die "Invalid address $_ resolved for $host\n" if /^(128|255)/s;
	}
	return $resolved{$host} = \@ips;
}


__END__

=head1 NAME

vzfirewall - A simple firewall for OpenVZ


=head1 SYNOPSIS

B<vzfirewall> (B<-h>|B<-V>|B<-a>|B<-t>) [B<option> ...]

You B<must> specify an action with one of the following:

=over 20

=item B<-h>, B<--help>

Display this help and exit.

=item B<-V>, B<--version>

Output vzfirewall version and exit.

=item B<-a>, B<--apply>

Apply iptables rules in openvz container *.conf files (FIREWALL directives).

=item B<-t>, B<--test>

Preview iptables rules in openvz container *.conf files without activation.

=back

You B<may> specify any of the options:

=over 20

=item B<-c>, B<--conf>, B<vzfw-conf>=I<PATH>

Location of vzfirewall configuration file.

=item B<-f>, B<--force>

Force rewrite of iptables rules even if rules are unchanged.

=item B<-d>, B<--dir>, B<--openvz-conf-dir>=I<PATH>

Specify directory containing per-container .conf files.

=item B<--rules>, B<--iptables-rules>=I<PATH>

Store iptables rules in this file.

=item B<-v>, B<--verbose>

Be more verbose.

=back

You can change the default firewall behavior with the following options:

=over 20

=item B<--icmp-types>=I<types>

Specify allowed icmp types.

Default: 3 4 11 12 8 (destination-unreachable source-quench time-exceeded parameter-problem echo-request)

=item B<--failsafe-addrs>=I<addr>

Specify hosts allowed administrative (ssh) access to the openvz hardware node.
I<addr> can be a single host, subnet, C<any> or C<none>.

Default: any

=back


=head1 DESCRIPTION

vzfirewall is a simple firewall for an openvz host
which protects both the openvz host and its containers.

vzfirewall uses openvz .conf files for configuration of
individual containers, just add a C<FIREWALL> directive
to specify the container's firewall rules.

vzfirewall can use an optional config file for system settings,
but does try to figure out it's environment and use sane defaults
so the config file often isn't needed.  Command line options
override the corresponding config file settings.


=head1 CONFIGURATION FILE

The C<vzfirewall.conf> file uses a basic B<name = value> syntax;
comments begin with #.

The following settings are supported:

=over 20

=item C<OPENVZ_CONF_DIR>

The location of openvz container configuration files.

Corresponds to --openvz-conf-dir command-line option.

=item C<IPTABLES_RULES>

File that iptables rules will be written to.  This file needs to be
loaded using iptables-restore on system startup.

Corresponds to --iptables-rules command-line option.

=item C<ICMP_TYPES>

Allowed icmp types.

Corresponds to --icmp-types command-line option.

=item C<FAILSAFE_ADDRS>

Specify hosts allowed administrative (ssh) access to the openvz hardware node.

Corresponds to --failsafe-addrs command-line option.

=back


=head1 EXAMPLES


=head2 C<vzfirewall.conf>

The following C<vzfirewall.conf> is equivalent to the default settings
on a C<debian> system using C<iptables-persistent> to load iptables rules:

 OPENVZ_CONF_DIR = /etc/vz/conf
 IPTABLES_RULES  = /etc/iptables/rules.v4
 ICMP_TYPES = 3 4 11 12 8
 FAILSAFE_ADDRS = any


=head2 Firewall the OpenVZ host

A C<FIREWALL> directive in I<0.conf> specifies firewall rules
for the openvz host.  Add something like this to I</etc/vz/conf/0.conf>:

 #FIREWALL="
 #   # allow all access from the administrator's workstation
 #   admin.domain.com
 #
 #   # allow our OpenVZ Web Panel to talk to the owp hardware daemon
 #   [7767]
 #   owp.domain.com
 #
 #   # we run an ntp server on the openvz host
 #   [udp:123]
 #   *
 #"

Run C<vzfirewall -t> to test the configuration.
When it looks good, apply the new rules:  C<vzfirewall -a>.

Note the C<#> prefix character for the entire C<FIREWALL> directive
is intentional, other OpenVZ utilities issue warnings if left out.


=head2 Firewall a container

Say you have a container with C<CTID> I<123> running a web server.
(Use C<vzlist> to determine the container id.)  Add the following to 
I</etc/vz/conf/123.conf>:

 #FIREWALL="
 #   [80,443]
 #   *
 #"

Run C<vzfirewall -a> to apply the new rules.


=head1 FILES

=over

=item C</etc/vz/vzfirewall.conf>, C</etc/sysconfig/vzfirewall.conf>

Default vzfirewall configuration file locations.

=item C</etc/vz/conf/*.conf>, C</etc/sysconfig/vz-scripts/*.conf>

Default location of OpenVZ container .conf scripts.

=item C</etc/sysconfig/iptables>, C</etc/iptables/rules.v4>, C</etc/vz/vzfirewall.rules>

Default locations searched for stored iptables rules file.

=back


=head1 SEE ALSO

=over

=item L<iptables(8)>

administration tool for IPv4 packet filtering and NAT

=item L<ctid.conf(5)>

configuration file for an OpenVZ container

=item L<http://en.dklab.ru/lib/dklab_vzfirewall>

vzfirewall homepage

=item L<https://github.com/DmitryKoterov/vzfirewall>

Development and Latest Version

=back


=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; either version 2.1 of the License,
or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to:

=over 4

 The Free Software Foundation, Inc.
 51 Franklin Street
 Fifth Floor
 Boston, MA 02110-1301 USA

=back


=head1 AUTHORS

=over

=item Dmitry Koterov <dmitry.koterov@gmail.com>

=item Jesse Norell <jesse@kci.net>

=back

=cut

